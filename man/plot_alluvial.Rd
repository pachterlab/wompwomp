% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plot_alluvial.R
\name{plot_alluvial}
\alias{plot_alluvial}
\title{Generate an Alluvial Plot with Minimal Cluster Cross-over}
\usage{
plot_alluvial(
  df,
  graphing_columns = NULL,
  column1 = NULL,
  column2 = NULL,
  column_weights = NULL,
  sorting_algorithm = "neighbornet",
  optimize_column_order = TRUE,
  optimize_column_order_per_cycle = FALSE,
  matrix_initialization_value = 1e+06,
  same_side_matrix_initialization_value = 1e+06,
  weight_scalar = 5e+05,
  matrix_initialization_value_column_order = 1e+06,
  weight_scalar_column_order = 1,
  column_sorting_metric = "edge_crossing",
  column_sorting_algorithm = "tsp",
  cycle_start_positions = NULL,
  fixed_column = NULL,
  random_initializations = 1,
  set_seed = 42,
  color_boxes = TRUE,
  color_bands = FALSE,
  color_list = NULL,
  color_band_list = NULL,
  color_band_column = NULL,
  color_val = NULL,
  color_band_boundary = FALSE,
  match_order = "advanced",
  graphing_algorithm = "leiden",
  resolution = 1,
  cutoff = 0.5,
  alluvial_alpha = 0.5,
  include_labels_in_boxes = TRUE,
  include_axis_titles = TRUE,
  include_group_sizes = FALSE,
  output_plot_path = NULL,
  output_df_path = NULL,
  preprocess_data = TRUE,
  default_sorting = "alphabetical",
  box_width = 1/3,
  text_width = 1/4,
  min_text = 4,
  text_size = 14,
  auto_adjust_text = TRUE,
  axis_text_size = 2,
  axis_text_vjust = 0,
  save_height = 6,
  save_width = 6,
  dpi = 300,
  rasterise_alluvia = FALSE,
  keep_y_labels = FALSE,
  box_line_width = 1,
  verbose = FALSE,
  print_params = FALSE,
  make_intermediate_neighbornet_plots = FALSE,
  environment = "wompwomp_env",
  use_conda = TRUE,
  add_legend = FALSE,
  legend_loc = "right"
)
}
\arguments{
\item{df}{A data frame, tibble, or CSV file path. Must be in one of two formats:
(1) column_weights == NULL: Each row represents an entity, each column represents a grouping, and each entry represents the membership of the entity in that row to the grouping in that column. Must contain at least two columns (two graphing_columns).
(2) column_weights != NULL: Each row represents a combination of groupings, each column from \code{graphing_columns} represents a grouping, and the column \code{column_weights} represents the number of entities in that combination of groupings. Must contain at least three columns (two \code{graphing_columns}, one \code{column_weights}).}

\item{graphing_columns}{Optional character vector. Vector of column names from \code{df} to be used in graphing (i.e., alluvial plotting). Mutually exclusive with \code{column1} and \code{column2}.}

\item{column1}{Optional character. Can be used along with \code{column2} in place of \code{graphing_columns} if working with two columns only. Mutually exclusive with \code{graphing_columns}.}

\item{column2}{Optional character. Can be used along with \code{column1} in place of \code{graphing_columns} if working with two columns only. Mutually exclusive with \code{graphing_columns}.}

\item{column_weights}{Optional character. Column name from \code{df} that contains the weights of each combination of groupings if \code{df} is in format (2) (see above).}

\item{sorting_algorithm}{Character. Algorithm with which to sort the values in the dataframe. Can choose from {'neighbornet', 'tsp', 'greedy_wolf', 'greedy_wblf', 'random', 'none'}. 'neighbornet' performs sorting with NeighborNet (Bryant and Moulton, 2004). 'tsp' performs Traveling Salesman Problem solver from the TSP package. 'greedy_wolf' implements a custom greedy algorithm where one layer is fixed, and the other layer is sorted such that each node is positioned as close to its largest parent from the fixed side as possible in a greedy fashion. 'greedy_wblf' implements the 'greedy_wolf' algorithm described previously twice, treating each column as fixed in one iteration and free in the other iteration. 'greedy_wolf' and 'greedy_wblf' are only valid when \code{graphing_columns} has exactly two entries. 'random' randomly maps blocks. 'none' keeps the mappings as-is when passed into the function.}

\item{optimize_column_order}{Logical. If TRUE, will optimize the order of \code{graphing_columns} to minimize edge overlap. Only applies when \code{sorting_algorithm == 'neighbornet' or 'tsp'} and \code{length(graphing_columns) > 2}.}

\item{optimize_column_order_per_cycle}{Logical. If TRUE, will optimize the order of \code{graphing_columns} to minimize edge overlap upon each cycle. If FALSE, will optimize the order of \code{graphing_columns} to minimize edge overlap on the beginning cycle only. Only applies when \code{sorting_algorithm == 'neighbornet' or 'tsp'} and \code{length(graphing_columns) > 2}.}

\item{matrix_initialization_value}{Positive integer. Initialized value in distance matrix for nodes in different layers without a shared edge/path. Only applies when \code{sorting_algorithm == 'neighbornet' or 'tsp'}.}

\item{same_side_matrix_initialization_value}{Positive integer. Initialized value in distance matrix for nodes in the same layer. Only applies when \code{sorting_algorithm == 'neighbornet' or 'tsp'}.}

\item{weight_scalar}{Positive integer. Scalar with which to multiply edge weights after taking their -log in the distance matrix for nodes with a nonzero edge. Only applies when \code{sorting_algorithm == 'neighbornet' or 'tsp'}.}

\item{matrix_initialization_value_column_order}{Positive integer. Initialized value in distance matrix for optimizing column order. Only applies when \code{sorting_algorithm == 'neighbornet' or 'tsp'} and \code{optimize_column_order} is TRUE.}

\item{weight_scalar_column_order}{Positive integer. Scalar with which to loss function after taking their log1p in the distance matrix for optimizing column order. Only applies when \code{sorting_algorithm == 'neighbornet' or 'tsp'} and \code{optimize_column_order} is TRUE.}

\item{column_sorting_metric}{Character. Metric to use for determining column order. Options are "edge_crossing" (default) or "ARI". Only applies when \code{sorting_algorithm == 'neighbornet' or 'tsp'} and \code{optimize_column_order} is TRUE.}

\item{column_sorting_algorithm}{Character. Algorithm to use for determining column order. Options are "tsp" (default) or "neighbornet". Only applies when \code{sorting_algorithm == 'neighbornet' or 'tsp'} and \code{optimize_column_order} is TRUE.}

\item{cycle_start_positions}{Set. Cycle start positions to consider. Anything outside this set will be skipped. Only applies when \code{sorting_algorithm == 'neighbornet' or 'tsp'}.}

\item{fixed_column}{Character or Integer. Name or position of the column in \code{graphing_columns} to keep fixed during sorting. Only applies when \code{sorting_algorithm == 'greedy_wolf'}.}

\item{random_initializations}{Integer. Number of random initializations for the positions of each grouping in \code{graphing_columns}. Only applies when \code{sorting_algorithm == 'greedy_wolf' or sorting_algorithm == 'greedy_wblf'}.}

\item{set_seed}{Integer. Random seed for the \code{random_initializations} parameter (only applies when \code{sorting_algorithm == 'greedy_wolf' or sorting_algorithm == 'greedy_wblf'}), random initialization/shuffling of blocks (only applies when \code{default_sorting == 'random' or sorting_algorithm == 'random'}), TSP solver for block order or optimizing column order (only applies when \code{sorting_algorithm == 'tsp' or column_sorting_algorithm == 'tsp'}), and louvain/leiden clustering (only applies when \code{match_order == 'advanced'}). Depracated (recommended to set seed outside of fucntion call).}

\item{color_boxes}{Logical. Whether to color the strata/boxes (representing groups).}

\item{color_bands}{Logical. Whether to color the alluvia/edges (connecting the strata).}

\item{color_list}{Optional named list or vector of colors to override default group colors.}

\item{color_band_list}{Optional named list or vector of colors to override default band colors.}

\item{color_band_column}{Optional Character. Which column to use for coloring bands.}

\item{color_val}{Optional named list where the entries are colors and the names correspond to values of the dataframe that should use those colors}

\item{color_band_boundary}{Logical. Whether or not to color boundaries between bands}

\item{match_order}{Character. Matching colors methods. Choices are 'advanced' (default), 'none', 'left', 'right', or any value in \code{graphing_columns}.}

\item{graphing_algorithm}{Character. If \code{match_order == 'advanced'}, then choose graph clustering algorithm. Choices are 'leiden' (default) or 'louvain'.}

\item{resolution}{Numeric If \code{match_order == 'advanced'}, then choose resolution for the graph clustering algorithm. Affects coloring of both bands and boxes.}

\item{cutoff}{Numeric If \code{match_order != 'none' and match_order != 'advanced'}, sets the cutoff for color matching, below which a new color will be assigned.}

\item{alluvial_alpha}{Numeric between 0 and 1. Transparency level for the alluvial bands.}

\item{include_labels_in_boxes}{Logical. Whether to include text labels inside the rectangular group boxes.}

\item{include_axis_titles}{Logical. Whether to display axis titles for column1 and column2.}

\item{include_group_sizes}{Logical. If \code{TRUE}, includes group sizes in the labels (e.g., "Group A (42)").}

\item{output_plot_path}{Character. File path to save the plot (e.g., "plot.png"). If \code{NULL}, then will not be saved.}

\item{output_df_path}{Optional character. Output path for the output data frame, in CSV format. If \code{NULL}, then will not be saved.}

\item{preprocess_data}{Logical. If TRUE, will preprocess the data with the \code{data_preprocess} function.}

\item{default_sorting}{Character. Default column sorting in data_preprocess if integer columns do not exist. Will not affect output if \code{sorting_algorithm == 'neighbornet'}. Options are 'alphabetical' (default), 'reverse_alphabetical', 'increasing', 'decreasing', 'random'.}

\item{box_width}{Numeric between 0 and 1. Box width}

\item{text_width}{Numeric between 0 and 1. Text width}

\item{min_text}{Integer greater than 0. Min text}

\item{text_size}{Integer greater than 0. Text size (works whether auto_adjust_text is TRUE or FALSE).}

\item{auto_adjust_text}{Logical. Whether to automatically adjust text size to fit in box.}

\item{axis_text_size}{Integer greater than 0. Axis text size}

\item{axis_text_vjust}{Integer. Axis text vjust}

\item{save_height}{Integer greater than 0. Save height, in inches}

\item{save_width}{Integer greater than 0. Save width, in inches}

\item{dpi}{Integer greater than 0. DPI for \code{output_plot_path}, if \code{output_plot_path} is a raster image or \code{rasterise_alluvia} is TRUE}

\item{rasterise_alluvia}{Logical. Whether to rasterize the alluvia if \code{output_plot_path} is a PDF. Can save space if DPI low enough}

\item{keep_y_labels}{Keep y labels}

\item{box_line_width}{Box line width}

\item{verbose}{Logical. If TRUE, will display messages during the function.}

\item{print_params}{Logical. If TRUE, will print function params.}

\item{make_intermediate_neighbornet_plots}{Internal flag; not recommended to modify.}

\item{environment}{Character. Python environment (if applicable). Default: 'wompwomp_env'}

\item{use_conda}{Logical. Whether or not to use conda for Python (if applicable)}

\item{add_legend}{Logical. If TRUE, will generate a legend of the colors of boxes and alluvial}

\item{legend_loc}{Character. Location of legend. Only applies if \code{add_legened == TRUE}. Choices are 'right' (default), 'left', 'bottom', 'top'}
}
\value{
A \code{ggplot2} object representing the alluvial plot.
}
\description{
Creates a two-axis alluvial plot to visualize the relationship between two categorical groupings (e.g., cluster assignments from different methods),
minimizing crossover and aligning clusters based on agreement.
}
\examples{
# Example 1: df format 1
df <- data.frame(method1 = sample(1:3, 100, TRUE), method2 = sample(1:3, 100, TRUE))
p <- plot_alluvial(df,
    graphing_columns = c("method1", "method2"),
    sorting_algorithm = "tsp",
    column_sorting_algorithm = "tsp",
    match_order = "right")

# Example 2: df format 2
df <- data.frame(method1 = sample(1:3, 100, TRUE), method2 = sample(1:3, 100, TRUE))
clus_df_gather <- df |>
    dplyr::mutate_if(is.numeric, function(x) factor(x, levels = as.character(sort(unique(x))))) |>
    dplyr::group_by_all() |>
    dplyr::count(name = "value")
p <- plot_alluvial(
   clus_df_gather,
   graphing_columns = c("method1", "method2"),
   column_weights = "value",
   sorting_algorithm = "tsp",
   column_sorting_algorithm = "tsp",
   match_order = "right")

}
