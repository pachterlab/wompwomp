---
title: "Quick Start: An Introduction to wompwomp"
output:
    BiocStyle::html_document:
        toc: true
        toc_depth: 2
vignette: >
  %\VignetteIndexEntry{Quick Start: An Introduction to wompwomp}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r}
devtools::load_all() # !!! erase

# library(wompwomp)  #!!! uncomment
library(dplyr)
library(ggplot2)
library(ggalluvial)
library(ggforce)
library(igraph)
library(tibble)
library(tidyr)

set.seed(42)
```

```{r}
use_temp_dir <- FALSE

use_temp_dir <- (use_temp_dir || !interactive()) # ensure temp_dire when non-interactive always
output_dir <- ifelse(!use_temp_dir, here::here("vignettes", "output"), file.path(tempdir(), "vignette_output"))
dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)
```

We create a toy data frame that maps tissues (BRAIN, STOMACH, HEART, T CELL, B CELL) to clustering (1-4)
```{r}
df <- data.frame(
    tissue = c(
        "BRAIN", "BRAIN", "BRAIN",
        "STOMACH", "STOMACH", "STOMACH", "STOMACH", "STOMACH", "STOMACH",
        "HEART", "HEART", "HEART", "HEART", "HEART", "HEART", "HEART",
        "T CELL", "T CELL",
        "B CELL", "B CELL", "B CELL", "B CELL", "B CELL", "B CELL", "B CELL", "B CELL", "B CELL"
    ),
    cluster = c(
        1, 1, 2,
        1, 2, 2, 2, 2, 2,
        1, 3, 3, 3, 3, 3, 3,
        4, 4,
        4, 4, 4, 4, 4, 4, 4, 4, 4
    )
)

# write.csv(df, file = "vignette_intro_df_ungrouped.csv", row.names = FALSE, quote = FALSE)
head(df)
```

Group by tissue and cluster, counting the values in a new column value
```{r}
clus_df_gather <- df |>
    dplyr::mutate_if(is.numeric, function(x) factor(x, levels = as.character(sort(unique(x))))) |>
    dplyr::group_by_all() |>
    dplyr::count(name = "value")

# write.csv(clus_df_gather, file = "vignette_intro_df_grouped.csv", row.names = FALSE, quote = FALSE)
clus_df_gather
```


Plot with ggalluvial before sorting - notice especially how B CELLs cross down to cluster 4, and STOMACH crosses up to cluster 2 - we would like to straighten this out, and add colors to show corresponding groups
```{r}
# p1 <- ggplot(data = clus_df_gather, aes(axis1 = tissue, axis2 = cluster, y = value)) +
#     geom_alluvium() +
#     geom_stratum() +
#     scale_x_discrete(limits = c("tissue", "cluster"), expand = c(.2, .05)) +
#     geom_text(stat = "stratum", aes(label = after_stat(stratum))) +
#     theme_minimal()
# p1

p1 <- plot_alluvial(clus_df_gather, graphing_columns = c("tissue", "cluster"), column_weights = "value", sorting_algorithm = "none", color_boxes = FALSE, color_bands = TRUE, coloring_algorithm = "none", output_plot_path = file.path(output_dir, "intro_unsorted.pdf"), text_size = 15, axis_text_size = 25, axis_text_vjust = 0)
p1

# ggsave("wompwomp_unsorted.png", plot = p1, dpi = 300, bg = "white")
```

With color
```{r}
p1_5 <- plot_alluvial(clus_df_gather, graphing_columns = c("tissue", "cluster"), column_weights = "value", sorting_algorithm = "none", color_boxes = TRUE, coloring_algorithm = "advanced", resolution = 1, color_bands = TRUE, output_plot_path = file.path(output_dir, "intro_unsorted_matched_colors.pdf"), text_size = 15, axis_text_size = 25, axis_text_vjust = 0)
p1_5
```


Implementing a greedy heuristic for weighted one-layer free problem
```{r}
clus_df_gather_sorted_wolf <- data_sort(clus_df_gather, column1 = "tissue", column2 = "cluster", column_weights = "value", sorting_algorithm = "greedy_wolf")
clus_df_gather_sorted_wolf
```

Plot the alluvial plot with sorting and color matching
```{r}
p2 <- plot_alluvial(clus_df_gather, graphing_columns = c("tissue", "cluster"), column_weights = "value", sorting_algorithm = "greedy_wolf", fixed_column = 1, color_bands = TRUE, coloring_algorithm = "advanced", resolution = 1, output_plot_path = file.path(output_dir, "intro_WOLF.pdf"), text_size = 15, axis_text_size = 25, axis_text_vjust = 0)
# alternatively: p2 <- plot_alluvial(df, graphing_columns = c("tissue", "cluster") sorting_algorithm = "greedy_wolf", fixed_column = 1)
p2

# ggsave("wompwomp_WOLF.png", plot = p2, dpi = 300, bg = "white")
```

Notice how, because we kept the left layer fixed, B CELL and T CELL are separated far apart, even though we would minimize edge crossings if they were next to each other - we can fix this with the weighted both-layers free heuristic
```{r}
clus_df_gather_sorted_wblf <- data_sort(clus_df_gather, column1 = "tissue", column2 = "cluster", column_weights = "value", sorting_algorithm = "greedy_wblf") # output_df_path = "vignette_intro_df_cluster_wblf.csv"
clus_df_gather_sorted_wblf
```

```{r}
p3 <- plot_alluvial(clus_df_gather, graphing_columns = c("tissue", "cluster"), column_weights = "value", sorting_algorithm = "greedy_wblf", color_bands = TRUE, coloring_algorithm = "advanced", resolution = 1, output_plot_path = file.path(output_dir, "intro_WBLF.pdf"), text_size = 15, axis_text_size = 25, axis_text_vjust = 0) # output_plot_path = "vignette_intro_plot.png"
# alternatively: p3 <- plot_alluvial(df, graphing_columns = c("tissue", "cluster"), sorting_algorithm = "greedy_wblf")
p3

# ggsave("wompwomp_WBLF.png", plot = p3, dpi = 300, bg = "white")
```

But this still isn't optimal - let's try another algorithm
```{r}
clus_df_gather_sorted_nn <- data_sort(clus_df_gather, column1 = "tissue", column2 = "cluster", column_weights = "value", sorting_algorithm = "tsp", weight_scalar = 10) # output_df_path = "vignette_intro_df_cluster_wblf.csv"

p3_5 <- plot_alluvial(clus_df_gather, graphing_columns = c("tissue", "cluster"), column_weights = "value", sorting_algorithm = "tsp", color_boxes = FALSE, color_bands = TRUE, coloring_algorithm = "none", resolution = 2, output_plot_path = file.path(output_dir, "intro_NN_without_color.pdf"), text_size = 15, axis_text_size = 25, axis_text_vjust = 0, weight_scalar = 100)
# output_plot_path = "vignette_intro_plot.png"
# alternatively: p3 <- plot_alluvial(df, graphing_columns = c("tissue", "cluster"), sorting_algorithm = "neighbornet")

p3_5
```

```{r}
p4 <- plot_alluvial(clus_df_gather, graphing_columns = c("tissue", "cluster"), column_weights = "value", sorting_algorithm = "tsp", color_bands = TRUE, coloring_algorithm = "advanced", resolution = 1, output_plot_path = file.path(output_dir, "intro_NN.pdf"), text_size = 15, axis_text_size = 25, axis_text_vjust = 0, weight_scalar = 10)
p4

# ggsave("wompwomp_NN.png", plot = p4, dpi = 300, bg = "white")
# ggsave("wompwomp_NN_transparent.png", plot = p4, dpi = 300)
```

What is our objective value on clus_df_gather_sorted_wolf and clus_df_gather_sorted_wblf, where our objective function is the sum of products of overlapping edge weights?
```{r}
clus_df_gather_ungrouped <- clus_df_gather %>% ungroup()
clus_df_gather_ungrouped[["col1_int"]] <- as.integer(as.factor(clus_df_gather_ungrouped[["tissue"]]))
clus_df_gather_ungrouped[["col2_int"]] <- as.integer(as.factor(clus_df_gather_ungrouped[["cluster"]]))
crossing_edges_output_unsorted <- determine_crossing_edges(clus_df_gather_ungrouped, column1 = "col1_int", column2 = "col2_int", column_weights = "value")
crossing_edges_unsorted <- crossing_edges_output_unsorted$crossing_edges_df
# str(crossing_edges_unsorted[1:3])

crossing_edges_output_wolf <- determine_crossing_edges(clus_df_gather_sorted_wolf, column1 = "col1_int", column2 = "col2_int", column_weights = "value")
crossing_edges_wolf <- crossing_edges_output_wolf$crossing_edges_df
# str(crossing_edges_wolf[1:3])

crossing_edges_output_wblf <- determine_crossing_edges(clus_df_gather_sorted_wblf, column1 = "col1_int", column2 = "col2_int", column_weights = "value") # output_df_path = "vignette_intro_crossing_wblf.csv"
crossing_edges_wblf <- crossing_edges_output_wblf$crossing_edges_df
# str(crossing_edges_wblf[1:3])
# write.csv(crossing_edges_wblf, file = "crossing_edges_wblf.csv", row.names = FALSE, quote = FALSE)
# write.csv(crossing_edges_output_wblf$lode_df, file = "lodes_wblf.csv", row.names = FALSE, quote = FALSE)

crossing_edges_output_nn <- determine_crossing_edges(clus_df_gather_sorted_nn, column1 = "col1_int", column2 = "col2_int", column_weights = "value") # output_df_path = "vignette_intro_crossing_nn.csv"
crossing_edges_nn <- crossing_edges_output_nn$crossing_edges_df
str(crossing_edges_nn[1:3])
```

```{r}
objective_unsorted <- determine_weighted_layer_free_objective(crossing_edges_unsorted)
print(paste0("Objective (unsorted): ", objective_unsorted))

objective_wolf <- determine_weighted_layer_free_objective(crossing_edges_wolf)
print(paste0("Objective (greedy WOLF): ", objective_wolf))

objective_wblf <- determine_weighted_layer_free_objective(crossing_edges_wblf)
print(paste0("Objective (greedy WBLF): ", objective_wblf))

objective_nn <- determine_weighted_layer_free_objective(crossing_edges_nn)
print(paste0("Objective (NeighborNet): ", objective_nn))
```

```{r}
sessioninfo::session_info()
```

```{r}
# ---- Binary Indexed Tree (Fenwick Tree) ----
BIT <- R6::R6Class("BIT",
   public = list(
       tree_count = NULL,
       tree_weight = NULL,
       
       initialize = function(size) {
           self$tree_count <- integer(size + 1)
           self$tree_weight <- numeric(size + 1)
       },
       
       update = function(index, weight) {
           index <- index + 1L
           n <- length(self$tree_count)
           while (index < n) {
               self$tree_count[index] <- self$tree_count[index] + 1L
               self$tree_weight[index] <- self$tree_weight[index] + weight
               index <- index + bitwAnd(index, -index)
           }
       },
       
       query = function(index) {
           count <- 0L
           weight_sum <- 0.0
           index <- index + 1L
           while (index > 0L) {
               count <- count + self$tree_count[index]
               weight_sum <- weight_sum + self$tree_weight[index]
               index <- index - bitwAnd(index, -index)
           }
           list(count = count, weight_sum = weight_sum)
       },
       
       query_range = function(low, high) {
           q_high <- self$query(high)
           q_low <- self$query(low - 1L)
           list(
               count = q_high$count - q_low$count,
               weight_sum = q_high$weight_sum - q_low$weight_sum
           )
       }
   )
)

calculate_objective_fenwick <- function(df) {
    # Step 1: Sort by y1
    df_sorted <- df[order(df$y1), ]
    rownames(df_sorted) <- NULL
    
    # Step 2: Rank-compress y2 (higher y2 → higher rank)
    df_sorted$y2_rank <- match(df_sorted$y2, sort(unique(df_sorted$y2)))
    max_rank <- max(df_sorted$y2_rank)
    
    # Step 3: Initialize BIT
    bit <- BIT$new(size = max_rank + 2L)
    total_cross_weight <- 0.0
    
    for (i in seq_len(nrow(df_sorted))) {
        y2_rank <- df_sorted$y2_rank[i]
        weight <- df_sorted$count[i]
        
        # Count previous y2s > current (strictly greater)
        q <- bit$query_range(y2_rank + 1L, max_rank)
        total_cross_weight <- total_cross_weight + weight * q$weight_sum
        
        # Add current y2_rank to BIT
        bit$update(y2_rank, weight)
    }
    
    total_cross_weight
}

df <- data.frame(y1 = c(1, 3, 2, 4), y2 = c(4, 2, 3, 1), count = c(2, 1, 3, 4))
calculate_objective_fenwick(df)

df_hard <- data.frame(
  y1 = round(runif(15, 0, 10), 2),       # random y1 between 0 and 10
  y2 = round(rnorm(15, mean = 5, sd = 2), 2),  # random y2, some ties likely
  count = sample(1:10, 15, replace = TRUE)     # integer weights 1–10
)

calculate_objective_fenwick(df_hard)
```

```{r}
reticulate::use_condaenv("wompwomp_env", required = TRUE) # !!! erase

objective_fenwick_script_path <- file.path("/Users/joeyrich/Desktop/calculate_objective.py")
reticulate::source_python(objective_fenwick_script_path)
# calculate_objective_fenwick_python(df)
# calculate_objective_fenwick_python(df_hard)
```

```{r}
devtools::load_all()

make_more_tsp_3_layer_df_with_2_identical_layers <- function() {
    df <- data.frame(
        tissue = c(
            "BRAIN", "BRAIN", "BRAIN",
            "STOMACH", "STOMACH", "STOMACH", "STOMACH", "STOMACH", "STOMACH",
            "HEART", "HEART", "HEART", "HEART", "HEART", "HEART", "HEART",
            "T CELL", "T CELL",
            "B CELL", "B CELL", "B CELL", "B CELL", "B CELL", "B CELL", "B CELL", "B CELL", "B CELL"
        ),
        sex = c(
            "male", "female", "male",
            "female", "male", "female", "female", "male", "female",
            "male", "female", "male", "female", "male", "female", "male",
            "female", "male",
            "female", "male", "female", "male", "female", "male", "female", "female", "male"
        ),
        cluster = c(
            "BRAIN", "BRAIN", "BRAIN",
            "STOMACH", "STOMACH", "STOMACH", "STOMACH", "STOMACH", "STOMACH",
            "HEART", "HEART", "HEART", "HEART", "HEART", "HEART", "HEART",
            "T CELL", "T CELL",
            "B CELL", "B CELL", "B CELL", "B CELL", "B CELL", "B CELL", "B CELL", "B CELL", "B CELL"
        )
    )
    graphing_columns <- c("tissue", "cluster", "sex")

    list(
        df = df,
        graphing_columns = graphing_columns
    )
}

# input <- make_more_tsp_3_layer_df_with_2_identical_layers()
# df <- input$df
# graphing_columns <- input$graphing_columns
# 
# clus_df_gather <- data_preprocess(df = df, graphing_columns = graphing_columns)
# 
# clus_df_gather_sorted <- data_sort(clus_df_gather, graphing_columns = graphing_columns, column_weights = "value", sorting_algorithm = "tsp", optimize_column_order = TRUE, optimize_column_order_per_cycle = TRUE, weight_scalar = 1)

num <- determine_crossing_edges(clus_df_gather_sorted, graphing_columns = graphing_columns, load_df = FALSE, preprocess_data = FALSE, return_weighted_layer_free_objective = TRUE)

testthat::expect_equal(num, 48)
```


