---
title: "Real examples"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Real examples}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r}
devtools::load_all()
# library(wompwomp)
library(dplyr)
library(ggplot2)
library(ggalluvial)
library(ggforce)
library(igraph)
library(tibble)
library(tidyr)
library(reticulate)

wompwomp::setup_python_env()  #!!! erase
```

Set up our python environment
```{r setup-env, eval = FALSE}
wompwomp::setup_python_env()
```

```{r check-python, include = FALSE}
if (!reticulate::py_module_available("splitspy")) {
    message("❌ 'splitspy' not found. Run wompwomp::setup_python_env() and restart R.")
    knitr::knit_exit()
}
```

```{r}
use_temp_dir <- FALSE

use_temp_dir <- (use_temp_dir || !interactive())  # ensure temp_dire when non-interactive always
output_dir <- ifelse(!use_temp_dir, here::here("vignettes", "output"), file.path(tempdir(), "vignette_output"))
dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)
```

```{r}
kits_file <- file.path(output_dir, "kits_alluvial_data.csv")

if (!file.exists(kits_file)) {
    stop(sprintf("KiTS file not found, and is currently not available for download. Please place the file in '%s'", kits_file))
}

df <- read.csv(kits_file)

df$KiTS_dice_score_binned_broad <- cut(
  df$KiTS_dice_score,
  breaks = c(-Inf, 0.2, 0.7, 1),
  labels = c("0-0.2", "0.2-0.7", "0.7-1"),
  right = FALSE  # means intervals are [a, b)
)

df$USC_dice_score_binned_broad <- cut(
  df$USC_dice_score,
  breaks = c(-Inf, 0.2, 0.7, 1),
  labels = c("0-0.2", "0.2-0.7", "0.7-1"),
  right = FALSE  # means intervals are [a, b)
)
```

```{r}
graphing_columns <- c("KiTS_dice_score_binned", "USC_dice_score_binned")
p <- plot_alluvial(df, graphing_columns = graphing_columns, sorting_algorithm = "None", color_bands=TRUE, verbose=TRUE, output_plot_path = file.path(output_dir, "Segmentation_unsorted.pdf"), min_text = 0.01, save_height = 24, save_width = 24)
p
```

```{r}
p <- plot_alluvial(df, graphing_columns = graphing_columns, sorting_algorithm = "neighbornet", color_bands=TRUE, verbose=TRUE, output_plot_path = file.path(output_dir, "Segmentation_NN.pdf"), min_text = 0.01, save_height = 24, save_width = 24)
p
```

WOLF
```{r}
devtools::load_all()
plot_alluvial(df, graphing_columns = graphing_columns, sorting_algorithm = "greedy_WOLF", fixed_column = "KiTS_dice_score_binned", color_bands=TRUE, verbose=TRUE, random_initializations=3)
plot_alluvial(df, graphing_columns = graphing_columns, sorting_algorithm = "greedy_WBLF", color_bands=TRUE, verbose=TRUE, random_initializations = 3)
```



```{r}
graphing_columns <- c("gender", "Race", "radiographic_size_binned", "KiTS_dice_score_binned_broad")
# plot_alluvial(df, graphing_columns = graphing_columns, sorting_algorithm = "None", color_bands=TRUE, output_plot_path = file.path(output_dir, "Segmentation_stratified_KiTS_unsorted.pdf"), min_text = 0.01, save_height = 24, save_width = 24)
# plot_alluvial(df, graphing_columns = graphing_columns, sorting_algorithm = "neighbornet", color_bands=TRUE, output_plot_path = file.path(output_dir, "Segmentation_stratified_KiTS_NN.pdf"), min_text = 0.01, save_height = 24, save_width = 24, optimize_column_order = FALSE)
plot_alluvial(df, graphing_columns = graphing_columns, sorting_algorithm = "None", color_bands=TRUE, output_plot_path = file.path(output_dir, "Segmentation_stratified_KiTS_unsorted_colored_dice.pdf"), min_text = 0.01, save_height = 24, save_width = 24, color_band_list = c("#009E73", "#D55E00", "#56B4E9"), color_band_column = 'KiTS_dice_score_binned_broad', optimize_column_order = FALSE, verbose = TRUE)
plot_alluvial(df, graphing_columns = graphing_columns, sorting_algorithm = "neighbornet", color_bands=TRUE, output_plot_path = file.path(output_dir, "Segmentation_stratified_KiTS_NN_colored_dice.pdf"), color_band_list = c("#009E73", "#56B4E9", "#D55E00"), color_band_column = 'KiTS_dice_score_binned_broad', min_text = 0.01, save_height = 24, save_width = 24, optimize_column_order = FALSE, verbose = TRUE)
# plot_alluvial(df, graphing_columns = graphing_columns, sorting_algorithm = "neighbornet", color_bands=TRUE, output_plot_path = file.path(output_dir, "Segmentation_stratified_KiTS_NN_colored_ethnicity.pdf"), color_band_list = c("#009E73", "#F0E442", "#56B4E9", "#0072B2", "#E69F00", "#D55E00"), color_band_column = 'Race', min_text = 0.01, save_height = 24, save_width = 24, optimize_column_order = FALSE)
# plot_alluvial(df, graphing_columns = graphing_columns, sorting_algorithm = "neighbornet", color_bands=TRUE, output_plot_path = file.path(output_dir, "Segmentation_stratified_KiTS_NN_colored_size.pdf"), color_band_list = c("#009E73", "#D55E00", "green", "#E69F00", "#56B4E9"), color_band_column = 'radiographic_size_binned', min_text = 0.01, save_height = 24, save_width = 24, optimize_column_order = FALSE)
```

```{r}
graphing_columns <- c("gender", "Race", "radiographic_size_binned", "USC_dice_score_binned_broad")
# plot_alluvial(df, graphing_columns = graphing_columns, sorting_algorithm = "None", color_bands=TRUE, output_plot_path = file.path(output_dir, "Segmentation_stratified_USC_unsorted.pdf"), min_text = 0.01, save_height = 24, save_width = 24)
# plot_alluvial(df, graphing_columns = graphing_columns, sorting_algorithm = "neighbornet", color_bands=TRUE, output_plot_path = file.path(output_dir, "Segmentation_stratified_USC_NN.pdf"), min_text = 0.01, save_height = 24, save_width = 24, optimize_column_order = FALSE)
plot_alluvial(df, graphing_columns = graphing_columns, sorting_algorithm = "None", color_bands=TRUE, output_plot_path = file.path(output_dir, "Segmentation_stratified_USC_unsorted_colored_dice.pdf"), color_band_list = c("#D55E00", "#009E73", "#56B4E9"), color_band_column = 'USC_dice_score_binned_broad', min_text = 0.01, save_height = 24, save_width = 24, optimize_column_order = FALSE, verbose = TRUE)
plot_alluvial(df, graphing_columns = graphing_columns, sorting_algorithm = "neighbornet", color_bands=TRUE, output_plot_path = file.path(output_dir, "Segmentation_stratified_USC_NN_colored_dice.pdf"), color_band_list = c("#56B4E9", "#0072B2", "#D55E00"), color_band_column = 'USC_dice_score_binned_broad', min_text = 0.01, save_height = 24, save_width = 24, optimize_column_order = FALSE, verbose = TRUE)
# plot_alluvial(df, graphing_columns = graphing_columns, sorting_algorithm = "neighbornet", color_bands=TRUE, output_plot_path = file.path(output_dir, "Segmentation_stratified_USC_NN_colored_ethnicity.pdf"), color_band_list = c("#0072B2", "#009E73", "#56B4E9", "#F0E442", "#E69F00", "#D55E00"), color_band_column = 'Race', min_text = 0.01, save_height = 24, save_width = 24, optimize_column_order = FALSE)
```




GOT
```{r}
url <- "https://raw.githubusercontent.com/MattLunkes/GoT_Affiliations/master/got_char.csv"
got_file <- file.path(output_dir, "got_char.csv")
graphing_columns <- c("Origin", "Starting.Affiliation", "End.of.S1", "End.of.S2", "End.of.S3", "End.of.S4", "End.of.S5", "End.of.S6", "End.of.S7")

if (!file.exists(got_file)) {
    download.file(url, got_file, method = "curl")
}

df <- read.csv(got_file)
```

```{r}
p <- plot_alluvial(df, graphing_columns = graphing_columns, sorting_algorithm = "None", default_sorting = "alphabetical", color_bands=FALSE, verbose=TRUE, output_plot_path=file.path(output_dir, "GoT_unsorted_alphabetical.pdf"), min_text = 0.01, save_height = 24, save_width = 24)
p

p <- plot_alluvial(df, graphing_columns = graphing_columns, sorting_algorithm = "None", default_sorting = "reverse_alphabetical", color_bands=FALSE, verbose=TRUE, output_plot_path=file.path(output_dir, "GoT_unsorted_reverse_alphabetical.pdf"), min_text = 0.01, save_height = 24, save_width = 24)
p

p <- plot_alluvial(df, graphing_columns = graphing_columns, sorting_algorithm = "None", default_sorting = "increasing", color_bands=FALSE, verbose=TRUE, output_plot_path=file.path(output_dir, "GoT_unsorted_increasing.pdf"), min_text = 0.01, save_height = 24, save_width = 24)
p

p <- plot_alluvial(df, graphing_columns = graphing_columns, sorting_algorithm = "None", default_sorting = "decreasing", color_bands=FALSE, verbose=TRUE, output_plot_path=file.path(output_dir, "GoT_unsorted_decreasing.pdf"), min_text = 0.01, save_height = 24, save_width = 24)
p
```

```{r}
p <- plot_alluvial(df, graphing_columns = graphing_columns, sorting_algorithm = "random", color_bands=FALSE, verbose=TRUE, output_plot_path=file.path(output_dir, "GoT_random.pdf"), min_text = 0.01, save_height = 24, save_width = 24)
p

# df['Lannister_origin'] <- df["Origin"] == 'House Lannister'
df <- df %>%
    mutate(Lannister_origin = case_when(
        Origin == "House Lannister" ~ 1,
        Origin == "Westeros"        ~ 2,
        TRUE                        ~ 0
    ))
p <- plot_alluvial(df, graphing_columns = graphing_columns, sorting_algorithm = "random", optimize_column_order=FALSE, color_boxes=FALSE, color_bands=TRUE, min_text = 0.01, verbose=FALSE, color_band_list = c("grey", "#D55E00", "#56B4E9"), color_band_column = 'Lannister_origin', output_plot_path = file.path(output_dir, "GoT_random_lannister_origin.pdf"), save_height = 24, save_width = 24)
p

# df['Lannister_ending'] <- df["End.of.S7"] == 'Queen Cersei Lannister'
df <- df %>%
    mutate(Lannister_ending = case_when(
        End.of.S7 == "Queen Cersei Lannister" ~ 1,
        End.of.S7 == "Other, Westeros"        ~ 2,
        TRUE                        ~ 0
    ))
p <- plot_alluvial(df, graphing_columns = graphing_columns, sorting_algorithm = "random", optimize_column_order=FALSE, color_boxes=FALSE, color_bands=TRUE, min_text = 0.01, verbose=FALSE, color_band_list = c("grey", "#D55E00", "#56B4E9"), color_band_column = 'Lannister_ending', output_plot_path = file.path(output_dir, "GoT_random_lannister_ending.pdf"), save_height = 24, save_width = 24)
p
```

```{r}
p <- plot_alluvial(df, graphing_columns = graphing_columns, sorting_algorithm = "neighbornet", optimize_column_order=FALSE, color_bands=FALSE, min_text = 0.01, verbose=TRUE, output_plot_path=file.path(output_dir, "GoT_NN.pdf"), save_height = 24, save_width = 24)
p

# df['Lannister_origin'] <- df["Origin"] == 'House Lannister'
df <- df %>%
    mutate(Lannister_origin = case_when(
        Origin == "House Lannister" ~ 1,
        Origin == "Westeros"        ~ 2,
        TRUE                        ~ 0
    ))
p <- plot_alluvial(df, graphing_columns = graphing_columns, sorting_algorithm = "neighbornet", optimize_column_order=FALSE, color_boxes=FALSE, color_bands=TRUE, min_text = 0.01, verbose=TRUE, color_band_list = c("grey", "#D55E00", "#56B4E9"), color_band_column = 'Lannister_origin', output_plot_path = file.path(output_dir, "GoT_NN_lannister_origin.pdf"), save_height = 24, save_width = 24)
p

# df['Lannister_ending'] <- df["End.of.S7"] == 'Queen Cersei Lannister'
df <- df %>%
    mutate(Lannister_ending = case_when(
        End.of.S7 == "Queen Cersei Lannister" ~ 1,
        End.of.S7 == "Other, Westeros"        ~ 2,
        TRUE                        ~ 0
    ))
p <- plot_alluvial(df, graphing_columns = graphing_columns, sorting_algorithm = "neighbornet", optimize_column_order=FALSE, color_boxes=FALSE, color_bands=TRUE, min_text = 0.01, verbose=TRUE, color_band_list = c("grey", "#D55E00", "#56B4E9"), color_band_column = 'Lannister_ending', output_plot_path = file.path(output_dir, "GoT_NN_lannister_ending.pdf"), save_height = 24, save_width = 24)
p
```


Clustering
```{r}
if (!requireNamespace("DuoClustering2018", quietly = TRUE)) {
    stop("Package 'DuoClustering2018' is needed for this vignette. Please install it with BiocManager::install('DuoClustering2018').")
}
```

```{r}
# library(DuoClustering2018)
df_long <- DuoClustering2018::clustering_summary_filteredExpr10_Koh_v2()
# print(unique(df_long$method))
# graphing_columns <- c("PCAKmeans", "RtsneKmeans", "Seurat", "SC3")
graphing_columns <- c("PCAKmeans", "RtsneKmeans", "Seurat", "SC3", "CIDR", "PCAHC", "SC3svm", "pcaReduce", "TSCAN", "SAFE", "monocle", "RaceID2")  # FlowSOM and ascend have minimal data

head(df_long)
```

```{r}
# Add a unique row index per observation
df_long <- df_long %>%
    group_by(method) %>%
    mutate(obs_id = row_number()) %>%
    ungroup()

df <- df_long %>%
  select(obs_id, trueclass, method, cluster) %>%
  pivot_wider(
    id_cols = c(obs_id, trueclass),
    names_from = method,
    values_from = cluster
  ) %>%
  select(-obs_id)  # optional: remove if obs_id is no longer needed

df$FlowSOM <- NULL
df$ascend <- NULL

# Remove rows with >na_threshold fraction NA
na_threshold <- 0.8
df <- df[rowMeans(is.na(df)) <= na_threshold, ]

head(df)
```

Subsample for debugging
```{r}
sample_size <- NULL
if (!is.null(sample_size)) {
    set.seed(42)
    df <- df %>% slice_sample(n = sample_size)
} else {
    sample_size <- "full"
}
```

```{r}
devtools::load_all()
p <- plot_alluvial(df, graphing_columns = graphing_columns, sorting_algorithm = "random", color_bands=FALSE, verbose=TRUE, output_plot_path=file.path(output_dir, sprintf("clustering_%s_random.pdf", sample_size)), min_text = 0.01, save_height = 24, save_width = 24, rasterise_alluvia = FALSE, dpi = 50, color_band_list = c("#D55E00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#E69F00", "#CC79A7", "#666666", "#AD7700"), color_band_column = 'trueclass')
```

```{r}
devtools::load_all()
log_msgs <- character()

withCallingHandlers({
  p2 <- plot_alluvial(df, graphing_columns = graphing_columns, sorting_algorithm = "neighbornet", color_bands=FALSE, verbose=TRUE, optimize_column_order = FALSE, output_plot_path=file.path(output_dir, sprintf("clustering_%s_NN.pdf", sample_size)), min_text = 0.01, save_height = 24, save_width = 24, rasterise_alluvia = FALSE, dpi = 50, color_band_list = c("#D55E00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#E69F00", "#CC79A7", "#666666", "#AD7700"), color_band_column = 'trueclass')
}, message = function(m) {
  log_msgs <<- c(log_msgs, conditionMessage(m))
  # no muffling → still prints to console
})
```

```{r}
objectives <- stringr::str_match(log_msgs, "neighbornet_objective for iteration \\d+ = (\\d+)")[, 2]
objectives <- as.numeric(na.omit(objectives))

df_obj <- data.frame(
  iteration = seq_along(objectives),
  objective = objectives
)

ggplot(df_obj, aes(x = iteration, y = objective)) +
  geom_line(color = "blue") +
  scale_x_continuous(
    breaks = seq(0, length(objectives), by = 5),     # major ticks
    minor_breaks = seq(0, length(objectives), by = 1)  # minor ticks
  ) +
  labs(title = "NeighborNet Objective Over Iterations",
       x = "Iteration", y = "Objective") +
  theme_minimal()
```


```{r}
devtools::load_all()
cycle_start_positions <- c(12:25, 130:150)  # c(40:60, 140:160)  # choose based on finding some local optima above
column_sorting_metric <- "edge_crossing"  # edge_crossing or ARI
optimize_column_order_per_cycle <- TRUE

p3 <- plot_alluvial(df, graphing_columns = graphing_columns, sorting_algorithm = "neighbornet", color_bands=FALSE, verbose=TRUE, optimize_column_order = TRUE, optimize_column_order_per_cycle = optimize_column_order_per_cycle, output_plot_path=file.path(output_dir, sprintf("clustering_%s_NN_optimized_columns.pdf", sample_size)), min_text = 0.01, save_height = 24, save_width = 24, rasterise_alluvia = FALSE, dpi = 50, color_band_list = c("#D55E00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#E69F00", "#CC79A7", "#666666", "#AD7700"), color_band_column = 'trueclass', cycle_start_positions = cycle_start_positions, column_sorting_metric = column_sorting_metric)
```




```{r}
sessioninfo::session_info()
```
