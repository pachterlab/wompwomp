---
title: "Introduction to alluvialmatch"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to alluvialmatch}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r}
devtools::load_all()
# library(alluvialmatch)
library(dplyr)
library(ggplot2)
library(ggalluvial)
library(ggforce)
library(igraph)
library(tibble)
```

```{r}
library(reticulate)
conda_env <- "seurat_vs_scanpy"
Sys.setenv(RETICULATE_PYTHON = paste("/Users/joeyrich/miniconda3/envs", conda_env, "bin/python3.9", sep = "/"))
use_condaenv("/Users/joeyrich/miniconda3/envs/seurat_vs_scanpy/bin/python3.9", required = TRUE)
```

```{r}
# # OLD: did neighbornet for each pair of columns and used this as my matrix entries - but this doesn't consider that node orders likely differ, and thus it's not a great comparison
determine_column_order <- function(df, graphing_columns) {
    # this doesn't strictly need its own condition (2 choose 2 is 1 anyways), but does avoid a little overhead
    if (length(graphing_columns) == 2) {
        return(graphing_columns)
    }
    
    column_dist_matrix <- matrix(1e6, nrow = length(graphing_columns), ncol = length(graphing_columns),
                          dimnames = list(graphing_columns, graphing_columns))
    
    pairs <- combn(graphing_columns, 2)
    for (i in 1:ncol(pairs)) {
        column1 <- pairs[1, i]
        column2 <- pairs[2, i]
        cycle <- run_neighbornet(df, column1=column1, column2=column2)
        res <- determine_optimal_cycle_start(df, cycle, column1=column1, column2=column2)
        neighbornet_objective <- log(res$neighbornet_objective)
        
        column_dist_matrix[column1, column2] <- neighbornet_objective
        column_dist_matrix[column2, column1] <- neighbornet_objective
    }
    # Prepare data in R
    labels <- graphing_columns  # assuming this is a character vector
    column_dist_matrix <- column_dist_matrix
    mat_list <- split(column_dist_matrix, row(column_dist_matrix))  # convert R matrix to list of row-vectors
    reticulate::source_python(file.path(here::here(), "scripts", "run_neighbornet.py"))
    result <- neighbor_net(labels, column_dist_matrix)
    cycle <- result[[1]]
    cycle_mapped <- labels[cycle]
    
    # determine the optimal starting point for cycle
    adj_distances <- sapply(seq_len(length(cycle_mapped)), function(i) {
        from <- cycle_mapped[i]
        to <- cycle_mapped[(i %% length(cycle_mapped)) + 1]  # wraps around
        column_dist_matrix[from, to]
    })
    max_index <- which.max(adj_distances)
    
    cycle_mapped_optimal_start <- rotate_left(cycle_mapped, max_index)
    return(cycle_mapped_optimal_start)
}

run_neighbornet <- function(df, graphing_columns = NULL, column1 = NULL, column2 = NULL) {
    # ensure someone doesn't specify both graphing_columns and column1/2
    if (!is.null(graphing_columns) && (!is.null(column1) || !is.null(column2))) {
        stop("Specify either graphing_columns or column1/column2, not both.")
    }
    # if someone specifies column1/2, then use it
    if (is.null(graphing_columns) && (!is.null(column1) || !is.null(column2))) {
        graphing_columns <- c(column1, column2)
    }
    
    # map from string to int if needed
    clus_df_gather <- df |>
        dplyr::mutate_if(is.numeric, function(x) factor(x, levels = as.character(sort(unique(x))))) |>
        dplyr::group_by_all() |>
        dplyr::count(name = "value")
    
    # Add prefixes to distinguish node types
    
    # prefix is "tissue_"
    for (col in graphing_columns) {
        clus_df_gather[[col]] <- paste0(col, "_", clus_df_gather[[col]])
    }
    
    # prefix is "column1_"
    # for (i in seq_along(graphing_columns)) {
    #     col <- graphing_columns[i]
    #     clus_df_gather[[col]] <- paste0("column", i, "_", clus_df_gather[[col]])
    # }
    
    # Get all node names
    all_nodes <- sort(unique(unlist(clus_df_gather[graphing_columns])))
    
    # Compute full distance matrix based on -log(edge weight)
    # Initialize distance matrix
    full_dist_matrix <- matrix(1e6, nrow = length(all_nodes), ncol = length(all_nodes),
                          dimnames = list(all_nodes, all_nodes))
    
    # Get all 2-column combinations
    pairwise_groupings <- combn(graphing_columns, 2, simplify = FALSE)
    
    # For each combination, group and summarize
    summarized_results <- purrr::map(pairwise_groupings, function(cols) {
      clus_df_gather %>%
        group_by(across(all_of(cols))) %>%
        summarise(total_value = sum(value), .groups = "drop") %>%
        mutate(grouping = paste(cols, collapse = "+"))
    })
    
    # Combine into a single data frame
    final_result <- bind_rows(summarized_results)
    
    for (i in seq_len(nrow(final_result))) {
        grouping_str <- final_result$grouping[i]
        parts <- strsplit(grouping_str, "\\+")[[1]]
        column1_tmp <- parts[1]
        column2_tmp <- parts[2]
        
        n1 <- as.character(final_result[[column1_tmp]][i])
        n2 <- as.character(final_result[[column2_tmp]][i])
        w <- final_result$total_value[i]
        
        if (w > 0) {
            full_dist_matrix[n1, n2] <- -log(w)
            full_dist_matrix[n2, n1] <- -log(w)  # symmetric since graph is undirected
        }
    }
    
    # make sure all numbers are positive for neighbornet
    min_val_abs <- abs(min(full_dist_matrix))
    full_dist_matrix <- full_dist_matrix + (min_val_abs + 1)
    
    # Prepare data in R
    labels <- all_nodes  # assuming this is a character vector
    mat <- full_dist_matrix
    mat[is.infinite(mat)] <- 1e6
    mat[is.na(mat)] <- 1e6
    mat_list <- split(mat, row(mat))  # convert R matrix to list of row-vectors
    
    # Call Python function
    # result <- nn_mod$neighbor_net(labels, mat_list)
    reticulate::source_python(file.path(here::here(), "scripts", "run_neighbornet.py"))
    result <- neighbor_net(labels, mat)
    cycle <- result[[1]]
    splits <- result[[2]]
    
    cycle_mapped <- labels[cycle]
    
    # browser()
    
    return(cycle_mapped)
}

rotate_left <- function(vec, k = 1) {
    n <- length(vec)
    k <- k %% n
    if (k == 0) return(vec)
    c(vec[(k + 1):n], vec[1:k])
}

get_graph_groups <- function(cycle) {
  groups <- list()
  
  for (node in cycle) {
    prefix <- sub("_.*", "", node)  # Extract everything before the first underscore
    
    if (!prefix %in% names(groups)) {
      groups[[prefix]] <- c()
    }
    
    groups[[prefix]] <- c(groups[[prefix]], node)
  }
  
  return(groups)
}

determine_optimal_cycle_start <- function(df, cycle, graphing_columns = NULL, column1 = NULL, column2 = NULL, optimize_column_order = TRUE) {
    # ensure someone doesn't specify both graphing_columns and column1/2
    if (!is.null(graphing_columns) && (!is.null(column1) || !is.null(column2))) {
        stop("Specify either graphing_columns or column1/column2, not both.")
    }
    # if someone specifies column1/2, then use it
    if (is.null(graphing_columns) && (!is.null(column1) || !is.null(column2))) {
        graphing_columns <- c(column1, column2)
    }

    if (optimize_column_order) {
        graphing_columns <- determine_column_order(df, graphing_columns = graphing_columns)    
    } else {
        graphing_columns <- graphing_columns
    }
    
    #factorize input columns
    for (col in graphing_columns) {
      df[[col]] <- as.factor(as.character(df[[col]]))
    }
    
    neighbornet_objective_minimum <- Inf
    p_best_neighbornet <- NULL
    cycle_best <- NULL
    left_graph_best <- NULL
    right_graph_best <- NULL
    clus_df_gather_best <- NULL
    plots <- list()
    
    n <- length(cycle)
    for (i in 0:(n - 1)) {
        cycle_shifted <- rotate_left(cycle, i)
        graphs_list <- get_graph_groups(cycle_shifted)
        
        # remove prefix (column1_, etc)
        graphs_list_stripped <- lapply(graphs_list, function(x) {
            sub("^[^_]+_", "", x)
        })
    
        clus_df_gather_neighbornet <- df |>
            dplyr::mutate_if(is.numeric, function(x) factor(x, levels = as.character(sort(unique(x))))) |>
            dplyr::group_by_all() |>
            dplyr::count(name = "value")
        clus_df_gather_neighbornet <- ggforce::gather_set_data(clus_df_gather_neighbornet, 1:2)
        clus_df_gather_neighbornet <- clus_df_gather_neighbornet %>%
            ungroup() %>%
            slice(1:(n() %/% 2)) %>%              # keep first half of rows
            select(-id, -x, -y)
        
        graphing_columns_int <- c()
    
        for (j in seq_along(graphing_columns)) {
          col_name <- graphing_columns[j]
          int_col_name <- paste0("col", j, "_int")
          graph <- graphs_list_stripped[[col_name]]
        
          # Assign the new integer-mapped column
          clus_df_gather_neighbornet[[int_col_name]] <- match(clus_df_gather_neighbornet[[col_name]], graph)
        
          # Collect the new column name
          graphing_columns_int <- c(graphing_columns_int, int_col_name)
        }
        
        # go through each adjacent pair of columns and sum up their objectives
        # browser()
        neighbornet_objective <- 0
        for (j in seq_len(length(graphing_columns_int) - 1)) {
            col_a <- graphing_columns_int[j]
            col_b <- graphing_columns_int[j + 1]
          
            neighbornet_objective_sub <- determine_crossing_edges(
                clus_df_gather_neighbornet,
                column1 = col_a,
                column2 = col_b,
                fixed_column = NULL,
                return_weighted_layer_free_objective = TRUE
            )
            neighbornet_objective <- neighbornet_objective + neighbornet_objective_sub
        }
    
        # # print(neighbornet_objective)
        if (neighbornet_objective < neighbornet_objective_minimum) {
            neighbornet_objective_minimum <- neighbornet_objective
            cycle_best <- cycle_shifted
            individual_graphs <- graphs_list_stripped
            # p_best_neighbornet <- p_neighbornet
            clus_df_gather_best <- clus_df_gather_neighbornet
        }
    }
    return(list(cycle = cycle_best, individual_graphs = individual_graphs, neighbornet_objective = neighbornet_objective_minimum, clus_df_gather = clus_df_gather_best))
}
```

```{r}
df <- data.frame(
  tissue = c(
    1, 1, 1,
    2, 2, 2, 2, 2, 2,
    3, 3, 3, 3, 3, 3, 3,
    4, 4,
    5, 5, 5, 5, 5, 5, 5, 5, 5
  ),
  cluster = c(
    6, 6, 7,
    6, 7, 7, 7, 7, 7,
    6, 8, 8, 8, 8, 8, 8,
    8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8
  )
)
column1 <- "tissue"
column2 <- "cluster"
graphing_columns <- c(column1, column2)

# clus_df_gather_raw <- df |>
#     dplyr::mutate_if(is.numeric, function(x) factor(x, levels = as.character(sort(unique(x))))) |>
#     dplyr::group_by_all() |>
#     dplyr::count(name = "value")
# gather_set_data(clus_df_gather_raw, 1:2)

plot_alluvial(df, column1="tissue", column2="cluster", sorting_algorithm = "None", color_bands=TRUE)
```

```{r}
cycle <- run_neighbornet(df, graphing_columns = graphing_columns)
res <- determine_optimal_cycle_start(df, cycle, graphing_columns = graphing_columns)
clus_df_gather_neighbornet <- res$clus_df_gather

p_neighbornet <- plot_alluvial(clus_df_gather_neighbornet, column1="col1_int", column2="col2_int", column_weights = "value", sorting_algorithm="None", color_bands=TRUE)
print(res$individual_graphs)
p_neighbornet
```

3+ columns
```{r}
df <- data.frame(
  tissue = c(
    "BRAIN", "BRAIN", "BRAIN",
    "STOMACH", "STOMACH", "STOMACH", "STOMACH", "STOMACH", "STOMACH",
    "HEART", "HEART", "HEART", "HEART", "HEART", "HEART", "HEART",
    "T CELL", "T CELL",
    "B CELL", "B CELL", "B CELL", "B CELL", "B CELL", "B CELL", "B CELL", "B CELL", "B CELL"
  ),
  cluster = c(
    1, 1, 2,
    1, 2, 2, 2, 2, 2,
    1, 3, 3, 3, 3, 3, 3,
    4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4
  ),
  sex = c(
    "male", "female", "male",
    "female", "male", "female", "female", "male", "female",
    "male", "female", "male", "female", "male", "female", "male",
    "female", "male",
    "female", "male", "female", "male", "female", "male", "female", "female", "male"
  )
)
graphing_columns <- c("tissue", "cluster", "sex")

plot_alluvial(df, graphing_columns = graphing_columns, sorting_algorithm = "None", color_bands=TRUE)
```

```{r}
optimize_column_order <- FALSE

cycle <- run_neighbornet(df, graphing_columns=graphing_columns)
res <- determine_optimal_cycle_start(df, cycle, graphing_columns=graphing_columns, optimize_column_order=optimize_column_order)
clus_df_gather_neighbornet <- res$clus_df_gather

graphing_columns_int <- c("col1_int", "col2_int", "col3_int")  #!!! un-harcode
p_neighbornet <- plot_alluvial(clus_df_gather_neighbornet, graphing_columns = graphing_columns_int, column_weights = "value", sorting_algorithm="None", color_bands=TRUE)
print(res$individual_graphs)
p_neighbornet
```

```{r}
# objective_original <- determine_crossing_edges(
#     clus_df_gather_neighbornet,
#     column1 = "col2_int",
#     column2 = "col3_int",
#     fixed_column = NULL,
#     return_weighted_layer_free_objective = TRUE
# )
# 
# clus_df_flipped <- clus_df_gather_neighbornet
# clus_df_flipped$col3_int <- ifelse(clus_df_flipped$col3_int == 1, 2, 1)
# 
# objective_flipped <- determine_crossing_edges(
#     clus_df_flipped,
#     column1 = "col2_int",
#     column2 = "col3_int",
#     fixed_column = NULL,
#     return_weighted_layer_free_objective = TRUE
# )
# 
# print(objective_original)
# print(objective_flipped)
```

```{r}
optimize_column_order <- TRUE

cycle <- run_neighbornet(df, graphing_columns=graphing_columns)
res <- determine_optimal_cycle_start(df, cycle, graphing_columns=graphing_columns, optimize_column_order=optimize_column_order)
clus_df_gather_neighbornet <- res$clus_df_gather

graphing_columns_int <- c("col1_int", "col2_int", "col3_int")  #!!! un-harcode
p_neighbornet <- plot_alluvial(clus_df_gather_neighbornet, graphing_columns = graphing_columns_int, column_weights = "value", sorting_algorithm="None", color_bands=TRUE)
print(res$individual_graphs)
p_neighbornet
```



```{r}
sessioninfo::session_info()
```



BONUS: Let's try on an extreme example
```{r}
df <- data.frame(
  tissue = c(
    "BRAIN", "BRAIN", "BRAIN",
    "STOMACH", "STOMACH", "STOMACH", "STOMACH", "STOMACH", "STOMACH",
    "HEART", "HEART", "HEART", "HEART", "HEART", "HEART", "HEART",
    "T CELL", "T CELL",
    "B CELL", "B CELL", "B CELL", "B CELL", "B CELL", "B CELL", "B CELL", "B CELL", "B CELL"
  ),
  sex = c(
    "male", "female", "male",
    "female", "male", "female", "female", "male", "female",
    "male", "female", "male", "female", "male", "female", "male",
    "female", "male",
    "female", "male", "female", "male", "female", "male", "female", "female", "male"
  ),
  cluster = c(
    "BRAIN", "BRAIN", "BRAIN",
    "STOMACH", "STOMACH", "STOMACH", "STOMACH", "STOMACH", "STOMACH",
    "HEART", "HEART", "HEART", "HEART", "HEART", "HEART", "HEART",
    "T CELL", "T CELL",
    "B CELL", "B CELL", "B CELL", "B CELL", "B CELL", "B CELL", "B CELL", "B CELL", "B CELL"
  )
)
graphing_columns <- c("tissue", "sex", "cluster")

plot_alluvial(df, graphing_columns = graphing_columns, sorting_algorithm = "None", color_bands=TRUE)
```

```{r}
optimize_column_order <- FALSE

cycle <- run_neighbornet(df, graphing_columns=graphing_columns)
res <- determine_optimal_cycle_start(df, cycle, graphing_columns=graphing_columns, optimize_column_order=optimize_column_order)
clus_df_gather_neighbornet <- res$clus_df_gather

graphing_columns_int <- c("col1_int", "col2_int", "col3_int")  #!!! un-harcode
p_neighbornet <- plot_alluvial(clus_df_gather_neighbornet, graphing_columns = graphing_columns_int, column_weights = "value", sorting_algorithm="None", color_bands=TRUE)
print(res$individual_graphs)
p_neighbornet
```

```{r}
optimize_column_order <- TRUE

cycle <- run_neighbornet(df, graphing_columns=graphing_columns)
res <- determine_optimal_cycle_start(df, cycle, graphing_columns=graphing_columns, optimize_column_order=optimize_column_order)
clus_df_gather_neighbornet <- res$clus_df_gather

graphing_columns_int <- c("col1_int", "col2_int", "col3_int")  #!!! un-harcode
p_neighbornet <- plot_alluvial(clus_df_gather_neighbornet, graphing_columns = graphing_columns_int, column_weights = "value", sorting_algorithm="None", color_bands=TRUE)
print(res$individual_graphs)
p_neighbornet
```


