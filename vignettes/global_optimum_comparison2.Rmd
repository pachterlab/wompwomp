---
title: "Introduction to alluvialmatch"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to alluvialmatch}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r}
devtools::load_all()
# library(alluvialmatch)
library(dplyr)
library(ggplot2)
library(ggalluvial)
library(ggforce)
library(igraph)
library(tibble)
```

```{r}
library(reticulate)
conda_env <- "seurat_vs_scanpy"
Sys.setenv(RETICULATE_PYTHON = paste("/Users/joeyrich/miniconda3/envs", conda_env, "bin/python3.9", sep = "/"))
use_condaenv("/Users/joeyrich/miniconda3/envs/seurat_vs_scanpy/bin/python3.9", required = TRUE)
```

```{r}
df <- data.frame(
  tissue = c(
    1, 1, 1,
    2, 2, 2, 2, 2, 2,
    3, 3, 3, 3, 3, 3, 3,
    4, 4,
    5, 5, 5, 5, 5, 5, 5, 5, 5
  ),
  cluster = c(
    6, 6, 7,
    6, 7, 7, 7, 7, 7,
    6, 8, 8, 8, 8, 8, 8,
    8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8
  )
)
column1 <- "tissue"
column2 <- "cluster"

clus_df_gather_raw <- df |>
    dplyr::mutate_if(is.numeric, function(x) factor(x, levels = as.character(sort(unique(x))))) |>
    dplyr::group_by_all() |>
    dplyr::count(name = "value")
gather_set_data(clus_df_gather_raw, 1:2)

plot_alluvial(clus_df_gather_raw, column1="tissue", column2="cluster", column_weights = "value", sorting_algorithm = "None", color_bands=TRUE)
```

```{r}
run_neighbornet <- function(df, column1, column2) {
    # map from string to int if needed
    clus_df_gather <- df |>
        dplyr::mutate_if(is.numeric, function(x) factor(x, levels = as.character(sort(unique(x))))) |>
        dplyr::group_by_all() |>
        dplyr::count(name = "value")
    gather_set_data(clus_df_gather, 1:2)
    
    # Add prefixes to distinguish node types
    clus_df_gather[[column1]] <- paste0("left_", clus_df_gather[[column1]])
    clus_df_gather[[column2]] <- paste0("right_", clus_df_gather[[column2]])
    
    # Get all node names
    all_nodes <- sort(unique(c(clus_df_gather[[column1]], clus_df_gather[[column2]])))
    
    # Compute full distance matrix based on -log(edge weight)
    # Initialize distance matrix
    full_dist_matrix <- matrix(1e6, nrow = length(all_nodes), ncol = length(all_nodes),
                          dimnames = list(all_nodes, all_nodes))
    
    # Fill in distances based on -log(weight)
    for (i in seq_len(nrow(clus_df_gather))) {
      n1 <- as.character(clus_df_gather[[column1]][i])
      n2 <- as.character(clus_df_gather[[column2]][i])
      w  <- clus_df_gather$value[i]
      
      if (w > 0) {
          full_dist_matrix[n1, n2] <- -log(w)
          full_dist_matrix[n2, n1] <- -log(w)  # symmetric since graph is undirected
      }
    }
    
    # make sure all numbers are positive for neighbornet
    min_val_abs <- abs(min(full_dist_matrix))
    full_dist_matrix <- full_dist_matrix + (min_val_abs + 1)
    
    # Prepare data in R
    labels <- all_nodes  # assuming this is a character vector
    mat <- full_dist_matrix
    mat[is.infinite(mat)] <- 1e6
    mat[is.na(mat)] <- 1e6
    mat_list <- split(mat, row(mat))  # convert R matrix to list of row-vectors
    
    # Call Python function
    # result <- nn_mod$neighbor_net(labels, mat_list)
    reticulate::source_python(file.path(here::here(), "scripts", "run_neighbornet.py"))
    result <- neighbor_net(labels, mat)
    cycle <- result[[1]]
    splits <- result[[2]]
    
    cycle_mapped <- labels[cycle]
    
    return(cycle_mapped)
}

rotate_left <- function(vec, k = 1) {
    n <- length(vec)
    k <- k %% n
    if (k == 0) return(vec)
    c(vec[(k + 1):n], vec[1:k])
}

get_left_and_right_graphs <- function(cycle) {
    left_graph <- c()
    right_graph <- c()
    
    for (node in cycle) {
        if (startsWith(node, "left")) {
            left_graph <- c(left_graph, node)
        } else if (startsWith(node, "right")) {
            right_graph <- c(right_graph, node)
        } else{
            stop("Unrecognized node name")
        }
    }
    
    return(list(left_graph = left_graph, right_graph = right_graph))
}

determine_optimal_cycle_start <- function(df, cycle, column1, column2) {
    #factorize input columns
    df[[column1]] <- as.factor(as.character(df[[column1]]))
    df[[column2]] <- as.factor(as.character(df[[column2]]))
    
    neighbornet_objective_minimum <- Inf
    p_best_neighbornet <- NULL
    cycle_best <- NULL
    left_graph_best <- NULL
    right_graph_best <- NULL
    clus_df_gather_best <- NULL
    plots <- list()
    
    n <- length(cycle)
    for (i in 0:(n - 1)) {
        cycle_shifted <- rotate_left(cycle, i)
        left_and_right_graph_list <- get_left_and_right_graphs(cycle_shifted)
        left_graph_rotated <- left_and_right_graph_list$left_graph
        right_graph_rotated <- left_and_right_graph_list$right_graph
        
        left_graph_rotated <- sub("^left_", "", left_graph_rotated)
        right_graph_rotated <- sub("^right_", "", right_graph_rotated)
    
        clus_df_gather_neighbornet <- df |>
            dplyr::mutate_if(is.numeric, function(x) factor(x, levels = as.character(sort(unique(x))))) |>
            dplyr::group_by_all() |>
            dplyr::count(name = "value")
        clus_df_gather_neighbornet <- ggforce::gather_set_data(clus_df_gather_neighbornet, 1:2)
        clus_df_gather_neighbornet <- clus_df_gather_neighbornet %>%
            ungroup() %>%
            slice(1:(n() %/% 2)) %>%              # keep first half of rows
            select(-id, -x, -y)
        
        clus_df_gather_neighbornet[['col1_int']] <- match(clus_df_gather_neighbornet[[column1]], left_graph_rotated)
        clus_df_gather_neighbornet[['col2_int']] <- match(clus_df_gather_neighbornet[[column2]], right_graph_rotated)
        
        # p_neighbornet <- plot_alluvial(clus_df_gather_neighbornet, column1="col1_int", column2="col2_int", column_weights = "value", sorting_algorithm="None", color_bands=TRUE)
        # plots[[i+1]] <- p_neighbornet
        
        neighbornet_objective <- determine_crossing_edges(
              clus_df_gather_neighbornet,
              column1 = "col1_int",
              column2 = "col2_int",
              fixed_column = NULL,
              return_weighted_layer_free_objective = TRUE
            )
        # print(neighbornet_objective)
        if (neighbornet_objective < neighbornet_objective_minimum) {
            neighbornet_objective_minimum <- neighbornet_objective
            cycle_best <- cycle_shifted
            left_graph_best <- left_graph_rotated
            right_graph_best <- right_graph_rotated
            # p_best_neighbornet <- p_neighbornet
            clus_df_gather_best <- clus_df_gather_neighbornet
        }
    }
    return(list(cycle = cycle_best, left_graph = left_graph_best, right_graph = right_graph_best, neighbornet_objective = neighbornet_objective_minimum, clus_df_gather = clus_df_gather_best))  # p_best = p_best_neighbornet
}
```

```{r}
cycle <- run_neighbornet(df, column1=column1, column2=column2)
res <- determine_optimal_cycle_start(df, cycle, column1=column1, column2=column2)
clus_df_gather_neighbornet <- res$clus_df_gather
# neighbornet_objective <- res$neighbornet_objective
# cycle <- res$cycle
# left_graph <- res$left_graph
# right_graph <- res$right_graph

p_neighbornet <- plot_alluvial(clus_df_gather_neighbornet, column1="col1_int", column2="col2_int", column_weights = "value", sorting_algorithm="None", color_bands=TRUE)
print(res$left_graph)
print(res$right_graph)
p_neighbornet
```

3+ columns
```{r}
df <- data.frame(
  tissue = c(
    "BRAIN", "BRAIN", "BRAIN",
    "STOMACH", "STOMACH", "STOMACH", "STOMACH", "STOMACH", "STOMACH",
    "HEART", "HEART", "HEART", "HEART", "HEART", "HEART", "HEART",
    "T CELL", "T CELL",
    "B CELL", "B CELL", "B CELL", "B CELL", "B CELL", "B CELL", "B CELL", "B CELL", "B CELL"
  ),
  cluster = c(
    1, 1, 2,
    1, 2, 2, 2, 2, 2,
    1, 3, 3, 3, 3, 3, 3,
    4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4
  ),
  sex = c(
    "male", "female", "male",
    "female", "male", "female", "female", "male", "female",
    "male", "female", "male", "female", "male", "female", "male",
    "female", "male",
    "female", "male", "female", "male", "female", "male", "female", "female", "male"
  )
)
graphing_columns <- c("tissue", "cluster", "sex")
optimize_column_order <- TRUE

plot_alluvial(df, graphing_columns = graphing_columns, sorting_algorithm = "None", color_bands=FALSE)
```

```{r}
determine_column_order <- function(df, graphing_columns) {
    # this doesn't strictly need its own condition (2 choose 2 is 1 anyways), but does avoid a little overhead
    if (length(graphing_columns) == 2) {
        return(graphing_columns)
    }
    
    column_dist_matrix <- matrix(1e6, nrow = length(graphing_columns), ncol = length(graphing_columns),
                          dimnames = list(graphing_columns, graphing_columns))
    
    pairs <- combn(graphing_columns, 2)
    for (i in 1:ncol(pairs)) {
        column1 <- pairs[1, i]
        column2 <- pairs[2, i]
        cycle <- run_neighbornet(df, column1=column1, column2=column2)
        res <- determine_optimal_cycle_start(df, cycle, column1=column1, column2=column2)
        neighbornet_objective <- log(res$neighbornet_objective)
        
        column_dist_matrix[column1, column2] <- neighbornet_objective
        column_dist_matrix[column2, column1] <- neighbornet_objective
    }
    # Prepare data in R
    labels <- graphing_columns  # assuming this is a character vector
    mat_list <- split(column_dist_matrix, row(column_dist_matrix))  # convert R matrix to list of row-vectors
    reticulate::source_python(file.path(here::here(), "scripts", "run_neighbornet.py"))
    result <- neighbor_net(labels, mat)
    cycle <- result[[1]]
    cycle_mapped <- labels[cycle]
    
    # determine the optimal starting point for cycle
    adj_distances <- sapply(seq_len(length(cycle_mapped)), function(i) {
        from <- cycle_mapped[i]
        to <- cycle_mapped[(i %% length(cycle_mapped)) + 1]  # wraps around
        column_dist_matrix[from, to]
    })
    max_index <- which.max(adj_distances)
    
    cycle_mapped_optimal_start <- rotate_left(cycle_mapped, max_index)
    return(cycle_mapped_optimal_start)
}

run_neighbornet <- function(df, graphing_columns) {
    # map from string to int if needed
    clus_df_gather <- df |>
        dplyr::mutate_if(is.numeric, function(x) factor(x, levels = as.character(sort(unique(x))))) |>
        dplyr::group_by_all() |>
        dplyr::count(name = "value")
    
    # Add prefixes to distinguish node types
    for (i in seq_along(graphing_columns)) {
        col <- graphing_columns[i]
        clus_df_gather[[col]] <- paste0("column", i, "_", clus_df_gather[[col]])
    }
    
    # Get all node names
    all_nodes <- sort(unique(unlist(clus_df_gather[graphing_columns])))
    
    # Compute full distance matrix based on -log(edge weight)
    # Initialize distance matrix
    full_dist_matrix <- matrix(1e6, nrow = length(all_nodes), ncol = length(all_nodes),
                          dimnames = list(all_nodes, all_nodes))
    
    # Get all 2-column combinations
    pairwise_groupings <- combn(graphing_columns, 2, simplify = FALSE)
    
    # For each combination, group and summarize
    summarized_results <- purrr::map(pairwise_groupings, function(cols) {
      clus_df_gather %>%
        group_by(across(all_of(cols))) %>%
        summarise(total_value = sum(value), .groups = "drop") %>%
        mutate(grouping = paste(cols, collapse = "+"))
    })
    
    # Combine into a single data frame
    final_result <- bind_rows(summarized_results)
    
    for (i in seq_len(nrow(final_result))) {
        grouping_str <- final_result$grouping[i]
        parts <- strsplit(grouping_str, "\\+")[[1]]
        column1_tmp <- parts[1]
        column2_tmp <- parts[2]
        
        n1 <- as.character(final_result[[column1_tmp]][i])
        n2 <- as.character(final_result[[column2_tmp]][i])
        grouping_str <- final_result$value[i]
        
        if (w > 0) {
            full_dist_matrix[n1, n2] <- -log(w)
            full_dist_matrix[n2, n1] <- -log(w)  # symmetric since graph is undirected
        }
    }
    
    # make sure all numbers are positive for neighbornet
    min_val_abs <- abs(min(full_dist_matrix))
    full_dist_matrix <- full_dist_matrix + (min_val_abs + 1)
    
    # Prepare data in R
    labels <- all_nodes  # assuming this is a character vector
    mat <- full_dist_matrix
    mat[is.infinite(mat)] <- 1e6
    mat[is.na(mat)] <- 1e6
    mat_list <- split(mat, row(mat))  # convert R matrix to list of row-vectors
    
    # Call Python function
    # result <- nn_mod$neighbor_net(labels, mat_list)
    reticulate::source_python(file.path(here::here(), "scripts", "run_neighbornet.py"))
    result <- neighbor_net(labels, mat)
    cycle <- result[[1]]
    splits <- result[[2]]
    
    cycle_mapped <- labels[cycle]
    
    return(cycle_mapped)
}

rotate_left <- function(vec, k = 1) {
    n <- length(vec)
    k <- k %% n
    if (k == 0) return(vec)
    c(vec[(k + 1):n], vec[1:k])
}

get_graph_groups <- function(cycle) {
  groups <- list()
  
  for (node in cycle) {
    prefix <- sub("_.*", "", node)  # Extract everything before the first underscore
    
    if (!prefix %in% names(groups)) {
      groups[[prefix]] <- c()
    }
    
    groups[[prefix]] <- c(groups[[prefix]], node)
  }
  
  return(groups)
}

determine_optimal_cycle_start <- function(df, cycle, graphing_columns) {
    #factorize input columns
    for (col in graphing_columns) {
      df[[col]] <- as.factor(as.character(df[[col]]))
    }
    
    neighbornet_objective_minimum <- Inf
    p_best_neighbornet <- NULL
    cycle_best <- NULL
    left_graph_best <- NULL
    right_graph_best <- NULL
    clus_df_gather_best <- NULL
    plots <- list()
    
    n <- length(cycle)
    for (i in 0:(n - 1)) {
        cycle_shifted <- rotate_left(cycle, i)
        graphs_list <- get_graph_groups(cycle_shifted)
        
        # remove prefix (column1_, etc)
        graphs_list_stripped <- lapply(graphs_list, function(x) {
            sub("^[^_]+_", "", x)
        })
    
        clus_df_gather_neighbornet <- df |>
            dplyr::mutate_if(is.numeric, function(x) factor(x, levels = as.character(sort(unique(x))))) |>
            dplyr::group_by_all() |>
            dplyr::count(name = "value")
        clus_df_gather_neighbornet <- ggforce::gather_set_data(clus_df_gather_neighbornet, 1:2)
        clus_df_gather_neighbornet <- clus_df_gather_neighbornet %>%
            ungroup() %>%
            slice(1:(n() %/% 2)) %>%              # keep first half of rows
            select(-id, -x, -y)
        
        graphing_columns_int <- c()
    
        for (i in seq_along(graphing_columns)) {
          col_name <- graphing_columns[i]
          int_col_name <- paste0("col", i, "_int")
          graph <- graphs_list_stripped[[i]]  # assuming this matches graphing_columns order
        
          # Assign the new integer-mapped column
          clus_df_gather_neighbornet[[int_col_name]] <- match(clus_df_gather_neighbornet[[col_name]], graph)
        
          # Collect the new column name
          graphing_columns_int <- c(graphing_columns_int, int_col_name)
        }
        
        # go through each adjacent pair of columns and sum up their objectives
        neighbornet_objective <- 0
        for (i in seq_len(length(graphing_columns_int) - 1)) {
            col_a <- graphing_columns_int[i]
            col_b <- graphing_columns_int[i + 1]
          
            neighbornet_objective_sub <- determine_crossing_edges(
                clus_df_gather_neighbornet,
                column1 = col_a,
                column2 = col_b,
                fixed_column = NULL,
                return_weighted_layer_free_objective = TRUE
            )
            neighbornet_objective <- neighbornet_objective + neighbornet_objective_sub
        }
    
        # # print(neighbornet_objective)
        if (neighbornet_objective < neighbornet_objective_minimum) {
            neighbornet_objective_minimum <- neighbornet_objective
            cycle_best <- cycle_shifted
            individual_graphs <- graphs_list_stripped
            right_graph_best <- right_graph_rotated
            # p_best_neighbornet <- p_neighbornet
            clus_df_gather_best <- clus_df_gather_neighbornet
        }
    }
    return(list(cycle = cycle_best, individual_graphs = individual_graphs, neighbornet_objective = neighbornet_objective_minimum, clus_df_gather = clus_df_gather_best))
}
```

```{r}
if (optimize_column_order) {
    graphing_columns_ordered <- determine_column_order(df, graphing_columns = c("tissue", "cluster", "sex"))    
} else {
    graphing_columns_ordered <- graphing_columns
}

cycle <- run_neighbornet(df, graphing_columns=graphing_columns_ordered)
res <- determine_optimal_cycle_start(df, cycle, graphing_columns=graphing_columns_ordered)
clus_df_gather_neighbornet <- res$clus_df_gather

graphing_columns_int <- c("col1_int", "col2_int", "col3_int")  #!!! un-harcode
p_neighbornet <- plot_alluvial(clus_df_gather_neighbornet, graphing_columns = graphing_columns_int, column_weights = "value", sorting_algorithm="None", color_bands=TRUE)
print(res$individual_graphs)
p_neighbornet
```

```{r}
# map from string to int if needed
clus_df_gather <- df |>
    dplyr::mutate_if(is.numeric, function(x) factor(x, levels = as.character(sort(unique(x))))) |>
    dplyr::group_by_all() |>
    dplyr::count(name = "value")

# Add prefixes to distinguish node types
for (i in seq_along(graphing_columns)) {
    col <- graphing_columns[i]
    clus_df_gather[[col]] <- paste0("column", i, "_", clus_df_gather[[col]])
}

# Get all node names
all_nodes <- sort(unique(unlist(clus_df_gather[graphing_columns])))

# Compute full distance matrix based on -log(edge weight)
# Initialize distance matrix
full_dist_matrix <- matrix(1e6, nrow = length(all_nodes), ncol = length(all_nodes),
                      dimnames = list(all_nodes, all_nodes))

# Get all 2-column combinations
pairwise_groupings <- combn(graphing_columns, 2, simplify = FALSE)

# For each combination, group and summarize
summarized_results <- purrr::map(pairwise_groupings, function(cols) {
  clus_df_gather %>%
    group_by(across(all_of(cols))) %>%
    summarise(total_value = sum(value), .groups = "drop") %>%
    mutate(grouping = paste(cols, collapse = "+"))
})

# Combine into a single data frame
final_result <- bind_rows(summarized_results)

for (i in seq_len(nrow(final_result))) {
    grouping_str <- final_result$grouping[i]
    parts <- strsplit(grouping_str, "\\+")[[1]]
    column1_tmp <- parts[1]
    column2_tmp <- parts[2]
    
    n1 <- as.character(final_result[[column1_tmp]][i])
    n2 <- as.character(final_result[[column2_tmp]][i])
    grouping_str <- final_result$value[i]
    
    if (w > 0) {
        full_dist_matrix[n1, n2] <- -log(w)
        full_dist_matrix[n2, n1] <- -log(w)  # symmetric since graph is undirected
    }
}

# make sure all numbers are positive for neighbornet
min_val_abs <- abs(min(full_dist_matrix))
full_dist_matrix <- full_dist_matrix + (min_val_abs + 1)

# Prepare data in R
labels <- all_nodes  # assuming this is a character vector
mat <- full_dist_matrix
mat[is.infinite(mat)] <- 1e6
mat[is.na(mat)] <- 1e6
mat_list <- split(mat, row(mat))  # convert R matrix to list of row-vectors

# Call Python function
# result <- nn_mod$neighbor_net(labels, mat_list)
reticulate::source_python(file.path(here::here(), "scripts", "run_neighbornet.py"))
result <- neighbor_net(labels, mat)
cycle <- result[[1]]
splits <- result[[2]]

cycle_mapped <- labels[cycle]

# return(cycle_mapped)


# ------------------------------------------------------------------------------------------------

cycle <- cycle_mapped

# ------------------------------------------------------------------------------------------------

#factorize input columns
df[[column1]] <- as.factor(as.character(df[[column1]]))
df[[column2]] <- as.factor(as.character(df[[column2]]))

neighbornet_objective_minimum <- Inf
p_best_neighbornet <- NULL
cycle_best <- NULL
left_graph_best <- NULL
right_graph_best <- NULL
clus_df_gather_best <- NULL
plots <- list()

n <- length(cycle)
for (i in 0:(n - 1)) {
    cycle_shifted <- rotate_left(cycle, i)
    graphs_list <- get_graph_groups(cycle_shifted)
    
    # remove prefix (column1_, etc)
    graphs_list_stripped <- lapply(graphs_list, function(x) {
        sub("^[^_]+_", "", x)
    })

    clus_df_gather_neighbornet <- df |>
        dplyr::mutate_if(is.numeric, function(x) factor(x, levels = as.character(sort(unique(x))))) |>
        dplyr::group_by_all() |>
        dplyr::count(name = "value")
    clus_df_gather_neighbornet <- ggforce::gather_set_data(clus_df_gather_neighbornet, 1:2)
    clus_df_gather_neighbornet <- clus_df_gather_neighbornet %>%
        ungroup() %>%
        slice(1:(n() %/% 2)) %>%              # keep first half of rows
        select(-id, -x, -y)
    
    graphing_columns_int <- c()

    for (i in seq_along(graphing_columns)) {
      col_name <- graphing_columns[i]
      int_col_name <- paste0("col", i, "_int")
      graph <- graphs_list_stripped[[i]]  # assuming this matches graphing_columns order
    
      # Assign the new integer-mapped column
      clus_df_gather_neighbornet[[int_col_name]] <- match(clus_df_gather_neighbornet[[col_name]], graph)
    
      # Collect the new column name
      graphing_columns_int <- c(graphing_columns_int, int_col_name)
    }
    
    # go through each adjacent pair of columns and sum up their objectives
    neighbornet_objective <- 0
    for (i in seq_len(length(graphing_columns_int) - 1)) {
        col_a <- graphing_columns_int[i]
        col_b <- graphing_columns_int[i + 1]
      
        neighbornet_objective_sub <- determine_crossing_edges(
            clus_df_gather_neighbornet,
            column1 = col_a,
            column2 = col_b,
            fixed_column = NULL,
            return_weighted_layer_free_objective = TRUE
        )
        neighbornet_objective <- neighbornet_objective + neighbornet_objective_sub
    }

    # # print(neighbornet_objective)
    if (neighbornet_objective < neighbornet_objective_minimum) {
        neighbornet_objective_minimum <- neighbornet_objective
        cycle_best <- cycle_shifted
        left_graph_best <- left_graph_rotated
        right_graph_best <- right_graph_rotated
        # p_best_neighbornet <- p_neighbornet
        clus_df_gather_best <- clus_df_gather_neighbornet
    }
}
```

```{r}
cycle <- run_neighbornet(df, column1=column1, column2=column2)
res <- determine_optimal_cycle_start(df, cycle, column1=column1, column2=column2)
clus_df_gather_neighbornet <- res$clus_df_gather
# neighbornet_objective <- res$neighbornet_objective
# cycle <- res$cycle
# left_graph <- res$left_graph
# right_graph <- res$right_graph

p_neighbornet <- plot_alluvial(clus_df_gather_neighbornet, column1="col1_int", column2="col2_int", column_weights = "value", sorting_algorithm="None", color_bands=TRUE)
print(res$left_graph)
print(res$right_graph)
p_neighbornet
```


```{r}
sessioninfo::session_info()
```
